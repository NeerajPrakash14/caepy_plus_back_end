"""Unit tests for voice onboarding endpoints."""

from __future__ import annotations

from datetime import UTC, datetime
from typing import TYPE_CHECKING
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

if TYPE_CHECKING:
    from httpx import AsyncClient

from src.app.core.exceptions import SessionNotFoundError


class DummyStatus:
    def __init__(self, value="active"):
        self.value = value

class DummySession:
    def __init__(self, is_complete=False):
        self.session_id = "test-uuid-123"
        self.status = DummyStatus()
        self.language = "en"
        self.collected_fields = {"name"}
        self.collected_data = {"name": "Dr. Smith"}
        self.field_confidence = {"name": 0.99}
        self.is_complete = is_complete
        self.turn_count = 1
        now = datetime.now(UTC)
        self.created_at = now
        self.updated_at = now
        self.expires_at = now
        self.missing_fields = ["specialization"] if not is_complete else []

    def get_active_config(self):
        return {
            "name": {"display": "Full Name", "required": True},
            "specialization": {"display": "Specialization", "required": True}
        }

@pytest.fixture
def mock_voice_service():
    """Override the voice service FastAPI dependency with a mock."""
    from src.app.main import app
    from src.app.services.voice_service import get_voice_service

    mock_svc = MagicMock()
    # Ensure async methods are AsyncMocks
    mock_svc.start_session = AsyncMock()
    mock_svc.process_message = AsyncMock()
    mock_svc.get_session_status = AsyncMock()
    mock_svc.finalize_session = AsyncMock()
    mock_svc.cancel_session = AsyncMock()

    # Use FastAPI's dependency_overrides so the DI system injects the mock
    app.dependency_overrides[get_voice_service] = lambda: mock_svc
    yield mock_svc
    # Clean up â€” remove only our override (conftest clears all after client scope)
    app.dependency_overrides.pop(get_voice_service, None)


@pytest.mark.asyncio
async def test_start_session(client: AsyncClient, auth_headers: dict[str, str], mock_voice_service: MagicMock) -> None:
    """Test starting a voice session."""
    session = DummySession()
    mock_voice_service.start_session.return_value = (session, "Hello Dr.")

    payload = {"language": "en"}
    response = await client.post("/api/v1/voice/start", json=payload, headers=auth_headers)

    assert response.status_code == 201
    data = response.json()
    # session_id is generated by the service; just verify it's a non-empty string
    assert isinstance(data["session_id"], str) and len(data["session_id"]) > 0
    assert data["greeting"] == "Hello Dr."

@pytest.mark.asyncio
async def test_process_chat(client: AsyncClient, auth_headers: dict[str, str], mock_voice_service: MagicMock) -> None:
    """Test processing a chat message."""
    session = DummySession()
    mock_voice_service.process_message.return_value = (session, "Got it.")

    payload = {
        "session_id": "test-uuid-123",
        "user_transcript": "My name is Smith"
    }
    response = await client.post("/api/v1/voice/chat", json=payload, headers=auth_headers)

    assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"
    data = response.json()
    assert data["ai_response"] == "Got it."
    assert data["is_complete"] is False

@pytest.mark.asyncio
async def test_get_session_status(client: AsyncClient, auth_headers: dict[str, str], mock_voice_service: MagicMock) -> None:
    """Test getting session status."""
    session = DummySession()
    mock_voice_service.get_session_status.return_value = session

    response = await client.get("/api/v1/voice/session/test-uuid-123", headers=auth_headers)

    assert response.status_code == 200
    data = response.json()
    assert data["session_id"] == "test-uuid-123"

@pytest.mark.asyncio
async def test_finalize_session_success(client: AsyncClient, auth_headers: dict[str, str], mock_voice_service: MagicMock) -> None:
    """Test finalising a complete session."""
    session = DummySession(is_complete=True)
    mock_voice_service.get_session_status.return_value = session
    mock_voice_service.finalize_session.return_value = {"name": "Dr. Smith", "specialization": "Cardiology"}

    response = await client.post("/api/v1/voice/session/test-uuid-123/finalize", headers=auth_headers)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert "doctor_data" in data

@pytest.mark.asyncio
async def test_finalize_session_incomplete(client: AsyncClient, auth_headers: dict[str, str], mock_voice_service: MagicMock) -> None:
    """Test finalising an incomplete session."""
    session = DummySession(is_complete=False)
    mock_voice_service.get_session_status.return_value = session

    response = await client.post("/api/v1/voice/session/test-uuid-123/finalize", headers=auth_headers)

    assert response.status_code == 400
    assert "Incomplete" in response.json()["detail"]["message"] or "incomplete" in response.json()["detail"]["error"].lower()

@pytest.mark.asyncio
async def test_cancel_session(client: AsyncClient, auth_headers: dict[str, str], mock_voice_service: MagicMock) -> None:
    """Test cancelling a session."""
    mock_voice_service.cancel_session.return_value = None

    response = await client.delete("/api/v1/voice/session/test-uuid-123", headers=auth_headers)
    assert response.status_code == 204

@pytest.mark.asyncio
async def test_session_not_found(client: AsyncClient, auth_headers: dict[str, str], mock_voice_service: MagicMock) -> None:
    """Test exception handling for missing sessions."""
    mock_voice_service.get_session_status.side_effect = SessionNotFoundError("Not found")

    response = await client.get("/api/v1/voice/session/missing-uuid", headers=auth_headers)
    assert response.status_code == 404
